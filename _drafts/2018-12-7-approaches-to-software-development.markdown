#Two Approaches
I've noticed that there are two approaches to building an app. The most common is the "beat it into shape" approach. With this approach the project starts with some structure, but is never restructured when requirements change. New features which don't fit the old model are shoehorned in. No one wants to change things that are already working so new features are built around the old code instead of integrated with it. This leads to duplicate code, convoluted logic and a generally messy codebase.

Without an overarching logic and structure to the code base, the proper fix for a bug is often unclear. This leads developers to write a quick patch or bandaid to fix the bug. More often than not, this will lead to further complications down the line. I call this approach "beating the code into shape". When a new bug is discovered, you beat it down. This causes another bug to surface so you beat that one down too. When developers refer to playing "Whack-a-mole" with the bugs, this is what they mean.

A lot of developers get stuck at this point in their progression. For simple apps, this approach will work and eventually you will ship something. However, if the requirements more complex, this approach quickly breaks down. You end up stuck with an architecture or design that doesn't model the requirements as they change. 

 I think a lot of developers get stuck in this phase because it works up to a point and they fear regressions generated by refactoring.
When you're forced to work on one of these code bases, you dream of all the changes you would make to make your life easier but are always forced to put them off until "later" when you have some time. Nobody wants to be the guy that broke everything. Eventually you will get to the point where you are adding as many bugs as you are fixing, perpetually fixing bugs but not adding functionality. You're treading water but not making any progress.
 At many companies, "refactor" is a dirty word. When management hears the word refactor, alarms go off in their heads. Refactor to them means, "we are going to break everything to keep the developers happy". When the R word is mentioned, stake holders start to squirm in their seats a little. And rightly so, they've probably been tramatized in the past where a team got to the point where they _had_ to do a big refactor. They go to the point where they were just treading water. They spend a month or two doing the _big_ refactor. At the end, the app looks the same, no bugs have been checked off the bug list and new bugs that were fixed in the past suddenly reappear.
The key to avoiding this state is constant refactoring. Refactoring shouldn't be something you do after problems have accumulated to the point where you can't add new features. It should be something you are constantly doing as part of adding any feature or bug fix. Requirements are always changing, your understanding of the problem space is constantly changing. Your software design needs to keep up.
One approach to enable developers to confidently refactor without breaking everything is to take a TDD approach. 

